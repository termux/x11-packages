diff -uNr SDL2-2.0.10/include/SDL_config.h SDL2-2.0.10.mod/include/SDL_config.h
--- SDL2-2.0.10/include/SDL_config.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_config.h	2019-08-20 20:36:55.072701171 +0300
@@ -37,8 +37,6 @@
 #include "SDL_config_macosx.h"
 #elif defined(__IPHONEOS__)
 #include "SDL_config_iphoneos.h"
-#elif defined(__ANDROID__)
-#include "SDL_config_android.h"
 #elif defined(__PSP__)
 #include "SDL_config_psp.h"
 #elif defined(__OS2__)
diff -uNr SDL2-2.0.10/include/SDL_egl.h SDL2-2.0.10.mod/include/SDL_egl.h
--- SDL2-2.0.10/include/SDL_egl.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_egl.h	2019-08-20 20:37:08.832784053 +0300
@@ -24,7 +24,7 @@
  *
  *  This is a simple file to encapsulate the EGL API headers.
  */
-#if !defined(_MSC_VER) && !defined(__ANDROID__)
+#if !defined(_MSC_VER)
 
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
@@ -421,15 +421,6 @@
 typedef struct gbm_bo      *EGLNativePixmapType;
 typedef void               *EGLNativeWindowType;
 
-#elif defined(__ANDROID__) /* Android */
-
-struct ANativeWindow;
-struct egl_native_pixmap_t;
-
-typedef struct ANativeWindow        *EGLNativeWindowType;
-typedef struct egl_native_pixmap_t  *EGLNativePixmapType;
-typedef void                        *EGLNativeDisplayType;
-
 #elif defined(MIR_EGL_PLATFORM)
 
 #include <mir_toolkit/mir_client_library.h>
diff -uNr SDL2-2.0.10/include/SDL_main.h SDL2-2.0.10.mod/include/SDL_main.h
--- SDL2-2.0.10/include/SDL_main.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_main.h	2019-08-20 20:37:18.832843960 +0300
@@ -63,17 +63,6 @@
  */
 #define SDL_MAIN_NEEDED
 
-#elif defined(__ANDROID__)
-/* On Android SDL provides a Java class in SDLActivity.java that is the
-   main activity entry point.
-
-   See docs/README-android.md for more details on extending that class.
- */
-#define SDL_MAIN_NEEDED
-
-/* We need to export SDL_main so it can be launched from Java */
-#define SDLMAIN_DECLSPEC    DECLSPEC
-
 #elif defined(__NACL__)
 /* On NACL we use ppapi_simple to set up the application helper code,
    then wait for the first PSE_INSTANCE_DIDCHANGEVIEW event before 
diff -uNr SDL2-2.0.10/include/SDL_platform.h SDL2-2.0.10.mod/include/SDL_platform.h
--- SDL2-2.0.10/include/SDL_platform.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_platform.h	2019-08-20 20:37:35.679610930 +0300
@@ -60,11 +60,6 @@
 #undef __LINUX__
 #define __LINUX__   1
 #endif
-#if defined(ANDROID) || defined(__ANDROID__)
-#undef __ANDROID__
-#undef __LINUX__ /* do we need to do this? */
-#define __ANDROID__ 1
-#endif
 
 #if defined(__APPLE__)
 /* lets us know what version of Mac OS X we're compiling on */
diff -uNr SDL2-2.0.10/include/SDL_rwops.h SDL2-2.0.10.mod/include/SDL_rwops.h
--- SDL2-2.0.10/include/SDL_rwops.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_rwops.h	2019-08-20 20:37:50.609699202 +0300
@@ -93,20 +93,7 @@
     Uint32 type;
     union
     {
-#if defined(__ANDROID__)
-        struct
-        {
-            void *fileNameRef;
-            void *inputStreamRef;
-            void *readableByteChannelRef;
-            void *readMethod;
-            void *assetFileDescriptorRef;
-            long position;
-            long size;
-            long offset;
-            int fd;
-        } androidio;
-#elif defined(__WIN32__)
+#if   defined(__WIN32__)
         struct
         {
             SDL_bool append;
diff -uNr SDL2-2.0.10/include/SDL_stdinc.h SDL2-2.0.10.mod/include/SDL_stdinc.h
--- SDL2-2.0.10/include/SDL_stdinc.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_stdinc.h	2019-08-20 20:38:04.559781166 +0300
@@ -332,7 +332,6 @@
 
 /** \cond */
 #ifndef DOXYGEN_SHOULD_IGNORE_THIS
-#if !defined(__ANDROID__)
    /* TODO: include/SDL_stdinc.h:174: error: size of array 'SDL_dummy_enum' is negative */
 typedef enum
 {
@@ -340,7 +339,6 @@
 } SDL_DUMMY_ENUM;
 
 SDL_COMPILE_TIME_ASSERT(enum, sizeof(SDL_DUMMY_ENUM) == sizeof(int));
-#endif
 #endif /* DOXYGEN_SHOULD_IGNORE_THIS */
 /** \endcond */
 
diff -uNr SDL2-2.0.10/include/SDL_system.h SDL2-2.0.10.mod/include/SDL_system.h
--- SDL2-2.0.10/include/SDL_system.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/include/SDL_system.h	2019-08-20 20:38:31.696605896 +0300
@@ -99,81 +99,6 @@
 
 #endif /* __IPHONEOS__ */
 
-
-/* Platform specific functions for Android */
-#if defined(__ANDROID__) && __ANDROID__
-
-/**
-   \brief Get the JNI environment for the current thread
-
-   This returns JNIEnv*, but the prototype is void* so we don't need jni.h
- */
-extern DECLSPEC void * SDLCALL SDL_AndroidGetJNIEnv(void);
-
-/**
-   \brief Get the SDL Activity object for the application
-
-   This returns jobject, but the prototype is void* so we don't need jni.h
-   The jobject returned by SDL_AndroidGetActivity is a local reference.
-   It is the caller's responsibility to properly release it
-   (using env->Push/PopLocalFrame or manually with env->DeleteLocalRef)
- */
-extern DECLSPEC void * SDLCALL SDL_AndroidGetActivity(void);
-
-/**
-   \brief Return true if the application is running on Android TV
- */
-extern DECLSPEC SDL_bool SDLCALL SDL_IsAndroidTV(void);
-
-/**
-   \brief Return true if the application is running on a Chromebook
- */
-extern DECLSPEC SDL_bool SDLCALL SDL_IsChromebook(void);
-
-/**
-  \brief Return true is the application is running on a Samsung DeX docking station
- */
-extern DECLSPEC SDL_bool SDLCALL SDL_IsDeXMode(void);
-
-/**
- \brief Trigger the Android system back button behavior.
- */
-extern DECLSPEC void SDLCALL SDL_AndroidBackButton(void);
-
-/**
-   See the official Android developer guide for more information:
-   http://developer.android.com/guide/topics/data/data-storage.html
-*/
-#define SDL_ANDROID_EXTERNAL_STORAGE_READ   0x01
-#define SDL_ANDROID_EXTERNAL_STORAGE_WRITE  0x02
-
-/**
-   \brief Get the path used for internal storage for this application.
-
-   This path is unique to your application and cannot be written to
-   by other applications.
- */
-extern DECLSPEC const char * SDLCALL SDL_AndroidGetInternalStoragePath(void);
-
-/**
-   \brief Get the current state of external storage, a bitmask of these values:
-    SDL_ANDROID_EXTERNAL_STORAGE_READ
-    SDL_ANDROID_EXTERNAL_STORAGE_WRITE
-
-   If external storage is currently unavailable, this will return 0.
-*/
-extern DECLSPEC int SDLCALL SDL_AndroidGetExternalStorageState(void);
-
-/**
-   \brief Get the path used for external storage for this application.
-
-   This path is unique to your application, but is public and can be
-   written to by other applications.
- */
-extern DECLSPEC const char * SDLCALL SDL_AndroidGetExternalStoragePath(void);
-
-#endif /* __ANDROID__ */
-
 /* Platform specific functions for WinRT */
 #if defined(__WINRT__) && __WINRT__
 
diff -uNr SDL2-2.0.10/src/atomic/SDL_atomic.c SDL2-2.0.10.mod/src/atomic/SDL_atomic.c
--- SDL2-2.0.10/src/atomic/SDL_atomic.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/atomic/SDL_atomic.c	2019-08-20 20:38:50.673382060 +0300
@@ -41,9 +41,7 @@
 #   if __has_builtin(__atomic_load_n)
       /* !!! FIXME: this advertises as available in the NDK but uses an external symbol we don't have.
          It might be in a later NDK or we might need an extra library? --ryan. */
-#     if !defined(__ANDROID__)
 #       define HAVE_ATOMIC_LOAD_N 1
-#     endif
 #   endif
 # elif defined(__GNUC__)
 #   if (__GNUC__ >= 5)
diff -uNr SDL2-2.0.10/src/dynapi/SDL_dynapi_procs.h SDL2-2.0.10.mod/src/dynapi/SDL_dynapi_procs.h
--- SDL2-2.0.10/src/dynapi/SDL_dynapi_procs.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/dynapi/SDL_dynapi_procs.h	2019-08-20 20:39:08.703485343 +0300
@@ -74,13 +74,6 @@
 SDL_DYNAPI_PROC(void,SDL_iPhoneSetEventPump,(SDL_bool a),(a),)
 #endif
 
-#ifdef __ANDROID__
-SDL_DYNAPI_PROC(void*,SDL_AndroidGetJNIEnv,(void),(),return)
-SDL_DYNAPI_PROC(void*,SDL_AndroidGetActivity,(void),(),return)
-SDL_DYNAPI_PROC(const char*,SDL_AndroidGetInternalStoragePath,(void),(),return)
-SDL_DYNAPI_PROC(int,SDL_AndroidGetExternalStorageState,(void),(),return)
-SDL_DYNAPI_PROC(const char*,SDL_AndroidGetExternalStoragePath,(void),(),return)
-#endif
 
 SDL_DYNAPI_PROC(int,SDL_Init,(Uint32 a),(a),return)
 SDL_DYNAPI_PROC(int,SDL_InitSubSystem,(Uint32 a),(a),return)
@@ -702,9 +695,6 @@
 #ifdef __WINRT__
 SDL_DYNAPI_PROC(SDL_WinRT_DeviceFamily,SDL_WinRTGetDeviceFamily,(void),(),return)
 #endif
-#ifdef __ANDROID__
-SDL_DYNAPI_PROC(SDL_bool,SDL_IsAndroidTV,(void),(),return)
-#endif
 SDL_DYNAPI_PROC(double,SDL_log10,(double a),(a),return)
 SDL_DYNAPI_PROC(float,SDL_log10f,(float a),(a),return)
 SDL_DYNAPI_PROC(char*,SDL_GameControllerMappingForDeviceIndex,(int a),(a),return)
@@ -712,11 +702,6 @@
 SDL_DYNAPI_PROC(int,SDL_LinuxSetThreadPriority,(Sint64 a, int b),(a,b),return)
 #endif
 SDL_DYNAPI_PROC(SDL_bool,SDL_HasAVX512F,(void),(),return)
-#ifdef __ANDROID__
-SDL_DYNAPI_PROC(SDL_bool,SDL_IsChromebook,(void),(),return)
-SDL_DYNAPI_PROC(SDL_bool,SDL_IsDeXMode,(void),(),return)
-SDL_DYNAPI_PROC(void,SDL_AndroidBackButton,(void),(),return)
-#endif
 SDL_DYNAPI_PROC(double,SDL_exp,(double a),(a),return)
 SDL_DYNAPI_PROC(float,SDL_expf,(float a),(a),return)
 SDL_DYNAPI_PROC(wchar_t*,SDL_wcsdup,(const wchar_t *a),(a),return)
diff -uNr SDL2-2.0.10/src/events/SDL_mouse.c SDL2-2.0.10.mod/src/events/SDL_mouse.c
--- SDL2-2.0.10/src/events/SDL_mouse.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/events/SDL_mouse.c	2019-08-20 20:53:48.094656920 +0300
@@ -114,7 +114,7 @@
 
     if (hint == NULL || *hint == '\0') {
         /* Default */
-#if defined(__ANDROID__) || (defined(__IPHONEOS__) && !defined(__TVOS__))
+#if (defined(__IPHONEOS__) && !defined(__TVOS__))
         mouse->mouse_touch_events = SDL_TRUE;
 #else
         mouse->mouse_touch_events = SDL_FALSE;
diff -uNr SDL2-2.0.10/src/file/SDL_rwops.c SDL2-2.0.10.mod/src/file/SDL_rwops.c
--- SDL2-2.0.10/src/file/SDL_rwops.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/file/SDL_rwops.c	2019-08-20 20:41:40.447661969 +0300
@@ -51,11 +51,6 @@
 #include "cocoa/SDL_rwopsbundlesupport.h"
 #endif /* __APPLE__ */
 
-#ifdef __ANDROID__
-#include "../core/android/SDL_android.h"
-#include "SDL_system.h"
-#endif
-
 #if __NACL__
 #include "nacl_io/nacl_io.h"
 #endif
@@ -515,64 +510,7 @@
         SDL_SetError("SDL_RWFromFile(): No file or no mode specified");
         return NULL;
     }
-#if defined(__ANDROID__)
-#ifdef HAVE_STDIO_H
-    /* Try to open the file on the filesystem first */
-    if (*file == '/') {
-        FILE *fp = fopen(file, mode);
-        if (fp) {
-            return SDL_RWFromFP(fp, 1);
-        }
-    } else {
-        /* Try opening it from internal storage if it's a relative path */
-        char *path;
-        FILE *fp;
-
-        /* !!! FIXME: why not just "char path[PATH_MAX];" ? */
-        path = SDL_stack_alloc(char, PATH_MAX);
-        if (path) {
-            SDL_snprintf(path, PATH_MAX, "%s/%s",
-                         SDL_AndroidGetInternalStoragePath(), file);
-            fp = fopen(path, mode);
-            SDL_stack_free(path);
-            if (fp) {
-                return SDL_RWFromFP(fp, 1);
-            }
-        }
-    }
-#endif /* HAVE_STDIO_H */
-
-    /* Try to open the file from the asset system */
-    rwops = SDL_AllocRW();
-    if (!rwops)
-        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */
-    if (Android_JNI_FileOpen(rwops, file, mode) < 0) {
-        SDL_FreeRW(rwops);
-        return NULL;
-    }
-    rwops->size = Android_JNI_FileSize;
-    rwops->seek = Android_JNI_FileSeek;
-    rwops->read = Android_JNI_FileRead;
-    rwops->write = Android_JNI_FileWrite;
-    rwops->close = Android_JNI_FileClose;
-    rwops->type = SDL_RWOPS_JNIFILE;
-
-#elif defined(__WIN32__)
-    rwops = SDL_AllocRW();
-    if (!rwops)
-        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */
-    if (windows_file_open(rwops, file, mode) < 0) {
-        SDL_FreeRW(rwops);
-        return NULL;
-    }
-    rwops->size = windows_file_size;
-    rwops->seek = windows_file_seek;
-    rwops->read = windows_file_read;
-    rwops->write = windows_file_write;
-    rwops->close = windows_file_close;
-    rwops->type = SDL_RWOPS_WINFILE;
-
-#elif HAVE_STDIO_H
+#if HAVE_STDIO_H
     {
         #ifdef __APPLE__
         FILE *fp = SDL_OpenFPFromBundleOrFallback(file, mode);
diff -uNr SDL2-2.0.10/src/joystick/SDL_gamecontroller.c SDL2-2.0.10.mod/src/joystick/SDL_gamecontroller.c
--- SDL2-2.0.10/src/joystick/SDL_gamecontroller.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/joystick/SDL_gamecontroller.c	2019-08-20 21:04:47.477665034 +0300
@@ -34,9 +34,6 @@
 #include "../events/SDL_events_c.h"
 #endif
 
-#if defined(__ANDROID__)
-#include "SDL_system.h"
-#endif
 
 
 /* Many controllers turn the center button into an instantaneous button press */
@@ -877,7 +874,7 @@
             ControllerMapping_t *pCurrMapping, *pPrevMapping;
 
             for ( pPrevMapping = s_pSupportedControllers, pCurrMapping = pPrevMapping->next;
-                  pCurrMapping; 
+                  pCurrMapping;
                   pPrevMapping = pCurrMapping, pCurrMapping = pCurrMapping->next ) {
                 continue;
             }
@@ -890,130 +887,6 @@
     return pControllerMapping;
 }
 
-#ifdef __ANDROID__
-/*
- * Helper function to guess at a mapping based on the elements reported for this controller
- */
-static ControllerMapping_t *SDL_CreateMappingForAndroidController(const char *name, SDL_JoystickGUID guid)
-{
-    SDL_bool existing;
-    char name_string[128];
-    char mapping_string[1024];
-    int button_mask;
-    int axis_mask;
-
-    button_mask = SDL_SwapLE16(*(Uint16*)(&guid.data[sizeof(guid.data)-4]));
-    axis_mask = SDL_SwapLE16(*(Uint16*)(&guid.data[sizeof(guid.data)-2]));
-    if (!button_mask && !axis_mask) {
-        /* Accelerometer, shouldn't have a game controller mapping */
-        return NULL;
-    }
-
-    /* Remove any commas in the name */
-    SDL_strlcpy(name_string, name, sizeof(name_string));
-    {
-        char *spot;
-        for (spot = name_string; *spot; ++spot) {
-            if (*spot == ',') {
-                *spot = ' ';
-            }
-        }
-    }
-    SDL_snprintf(mapping_string, sizeof(mapping_string), "none,%s,", name_string);
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_A)) {
-        SDL_strlcat(mapping_string, "a:b0,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_B)) {
-        SDL_strlcat(mapping_string, "b:b1,", sizeof(mapping_string));
-    } else if (button_mask & (1 << SDL_CONTROLLER_BUTTON_BACK)) {
-        /* Use the back button as "B" for easy UI navigation with TV remotes */
-        SDL_strlcat(mapping_string, "b:b4,", sizeof(mapping_string));
-        button_mask &= ~(1 << SDL_CONTROLLER_BUTTON_BACK);
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_X)) {
-        SDL_strlcat(mapping_string, "x:b2,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_Y)) {
-        SDL_strlcat(mapping_string, "y:b3,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_BACK)) {
-        SDL_strlcat(mapping_string, "back:b4,", sizeof(mapping_string));
-    }
-#if 0 /* The guide button generally isn't functional (or acts as a home button) on most Android controllers */
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_GUIDE)) {
-        SDL_strlcat(mapping_string, "guide:b5,", sizeof(mapping_string));
-#if 0 /* Actually this will be done in Steam */
-    } else if (button_mask & (1 << SDL_CONTROLLER_BUTTON_START)) {
-        /* The guide button doesn't exist, use the start button instead,
-           so you can do Steam guide button chords and open the Steam overlay.
-         */
-        SDL_strlcat(mapping_string, "guide:b6,", sizeof(mapping_string));
-        button_mask &= ~(1 << SDL_CONTROLLER_BUTTON_START);
-#endif
-    }
-#endif
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_START)) {
-        SDL_strlcat(mapping_string, "start:b6,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_LEFTSTICK)) {
-        SDL_strlcat(mapping_string, "leftstick:b7,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_RIGHTSTICK)) {
-        SDL_strlcat(mapping_string, "rightstick:b8,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_LEFTSHOULDER)) {
-        SDL_strlcat(mapping_string, "leftshoulder:b9,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_RIGHTSHOULDER)) {
-        SDL_strlcat(mapping_string, "rightshoulder:b10,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_DPAD_UP)) {
-        SDL_strlcat(mapping_string, "dpup:b11,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_DPAD_DOWN)) {
-        SDL_strlcat(mapping_string, "dpdown:b12,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_DPAD_LEFT)) {
-        SDL_strlcat(mapping_string, "dpleft:b13,", sizeof(mapping_string));
-    }
-    if (button_mask & (1 << SDL_CONTROLLER_BUTTON_DPAD_RIGHT)) {
-        SDL_strlcat(mapping_string, "dpright:b14,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_LEFTX)) {
-        SDL_strlcat(mapping_string, "leftx:a0,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_LEFTY)) {
-        SDL_strlcat(mapping_string, "lefty:a1,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_RIGHTX)) {
-        SDL_strlcat(mapping_string, "rightx:a2,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_RIGHTY)) {
-        SDL_strlcat(mapping_string, "righty:a3,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_TRIGGERLEFT)) {
-        SDL_strlcat(mapping_string, "lefttrigger:a4,", sizeof(mapping_string));
-    }
-    if (axis_mask & (1 << SDL_CONTROLLER_AXIS_TRIGGERRIGHT)) {
-        SDL_strlcat(mapping_string, "righttrigger:a5,", sizeof(mapping_string));
-    }
-
-    /* Remove trailing comma */
-    {
-        int pos = (int)SDL_strlen(mapping_string) - 1;
-        if (pos >= 0) {
-            if (mapping_string[pos] == ',') {
-                mapping_string[pos] = '\0';
-            }
-        }
-    }
-
-    return SDL_PrivateAddMappingForGUID(guid, mapping_string,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
-}
-#endif /* __ANDROID__ */
-
-
 /*
  * Helper function to determine pre-calculated offset to certain joystick mappings
  */
@@ -1039,11 +912,6 @@
             mapping = s_pXInputMapping;
         }
     }
-#ifdef __ANDROID__
-    if (!mapping && name && !SDL_IsJoystickHIDAPI(guid)) {
-        mapping = SDL_CreateMappingForAndroidController(name, guid);
-    }
-#endif
     if (!mapping) {
         mapping = s_pDefaultMapping;
     }
@@ -1081,12 +949,12 @@
     int controllers = 0;
     char *buf, *line, *line_end, *tmp, *comma, line_platform[64];
     size_t db_size, platform_len;
-    
+
     if (rw == NULL) {
         return SDL_SetError("Invalid RWops");
     }
     db_size = (size_t)SDL_RWsize(rw);
-    
+
     buf = (char *)SDL_malloc(db_size + 1);
     if (buf == NULL) {
         if (freerw) {
@@ -1094,7 +962,7 @@
         }
         return SDL_SetError("Could not allocate space to read DB into memory");
     }
-    
+
     if (SDL_RWread(rw, buf, db_size, 1) != 1) {
         if (freerw) {
             SDL_RWclose(rw);
@@ -1102,14 +970,14 @@
         SDL_free(buf);
         return SDL_SetError("Could not read DB");
     }
-    
+
     if (freerw) {
         SDL_RWclose(rw);
     }
-    
+
     buf[db_size] = '\0';
     line = buf;
-    
+
     while (line < buf + db_size) {
         line_end = SDL_strchr(line, '\n');
         if (line_end != NULL) {
@@ -1117,7 +985,7 @@
         } else {
             line_end = buf + db_size;
         }
-        
+
         /* Extract and verify the platform */
         tmp = SDL_strstr(line, SDL_CONTROLLER_PLATFORM_FIELD);
         if (tmp != NULL) {
@@ -1134,7 +1002,7 @@
                 }
             }
         }
-        
+
         line = line_end + 1;
     }
 
@@ -1320,7 +1188,7 @@
 }
 
 /*
- * Fill the given buffer with the expected controller mapping filepath. 
+ * Fill the given buffer with the expected controller mapping filepath.
  * Usually this will just be SDL_HINT_GAMECONTROLLERCONFIG_FILE, but for
  * Android, we want to get the internal storage path.
  */
@@ -1331,11 +1199,7 @@
         return SDL_strlcpy(path, hint, size) < size;
     }
 
-#if defined(__ANDROID__)
-    return SDL_snprintf(path, size, "%s/controller_map.txt", SDL_AndroidGetInternalStoragePath()) < size;
-#else
     return SDL_FALSE;
-#endif
 }
 
 /*
@@ -1356,7 +1220,7 @@
     }
 
     if (SDL_GetControllerMappingFilePath(szControllerMapPath, sizeof(szControllerMapPath))) {
-        SDL_GameControllerAddMappingsFromFile(szControllerMapPath);        
+        SDL_GameControllerAddMappingsFromFile(szControllerMapPath);
     }
 
     /* load in any user supplied config */
diff -uNr SDL2-2.0.10/src/joystick/SDL_gamecontrollerdb.h SDL2-2.0.10.mod/src/joystick/SDL_gamecontrollerdb.h
--- SDL2-2.0.10/src/joystick/SDL_gamecontrollerdb.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/joystick/SDL_gamecontrollerdb.h	2019-08-20 20:50:18.396976092 +0300
@@ -26,7 +26,7 @@
    The easiest way to generate a new mapping is to start Steam in Big Picture
    mode, configure your joystick and then look in config/config.vdf in your
    Steam installation directory for the "SDL_GamepadBind" entry.
-   
+
    Alternatively, you can use the app located in test/controllermap
  */
 static const char *s_ControllerMappings [] =
@@ -572,24 +572,6 @@
     "03000000b50700001503000010010000,impact,a:b2,b:b3,back:b8,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,leftshoulder:b4,leftstick:b10,lefttrigger:b5,leftx:a0,lefty:a1,rightshoulder:b6,rightstick:b11,righttrigger:b7,rightx:a3,righty:a2,start:b9,x:b0,y:b1,",
     "030000009b2800000300000001010000,raphnet.net 4nes4snes v1.5,a:b0,b:b4,back:b2,leftshoulder:b6,leftx:a0,lefty:a1,rightshoulder:b7,start:b3,x:b1,y:b5,",
 #endif
-#if defined(__ANDROID__)
-    "05000000d6020000e5890000dfff3f00,GPD XD Plus,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a3,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a4,rightx:a2,righty:a5,start:b6,x:b2,y:b3,",
-    "05000000bc20000000550000ffff3f00,GameSir G3w,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a5,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a4,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000005509000003720000cf7f3f00,NVIDIA Controller v01.01,a:b0,b:b1,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000005509000010720000ffff3f00,NVIDIA Controller v01.03,a:b0,b:b1,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000007e05000009200000ffff0f00,Nintendo Switch Pro Controller,a:b0,b:b1,back:b15,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b3,leftstick:b4,lefttrigger:b9,leftx:a0,lefty:a1,rightshoulder:b18,rightstick:b6,righttrigger:b10,rightx:a2,righty:a3,start:b16,x:b17,y:b2,", /* Extremely slow in Bluetooth mode on Android */
-    "050000004c05000068020000dfff3f00,PS3 Controller,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000004c050000c4050000fffe3f00,PS4 Controller,a:b1,b:b17,back:b15,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b3,leftstick:b4,lefttrigger:+a3,leftx:a0,lefty:a1,rightshoulder:b18,rightstick:b6,righttrigger:+a4,rightx:a2,righty:a5,start:b16,x:b0,y:b2,",
-    "050000004c050000cc090000fffe3f00,PS4 Controller,a:b1,b:b17,back:b15,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b3,leftstick:b4,lefttrigger:a3,leftx:a0,lefty:a1,rightshoulder:b18,rightstick:b6,righttrigger:a4,rightx:a2,righty:a5,start:b16,x:b0,y:b2,",
-    "050000003215000005070000ffff3f00,Razer Raiju Mobile,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000003215000007070000ffff3f00,Razer Raiju Mobile,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000003215000000090000bf7f3f00,Razer Serval,a:b0,b:b1,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,x:b2,y:b3,",
-    "05000000de2800000511000001000000,Steam Controller,a:b0,b:b1,back:b6,guide:b8,leftshoulder:b4,leftstick:b9,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,righttrigger:a3,start:b7,x:b2,y:b3,",
-    "05000000de2800000611000001000000,Steam Controller,a:b0,b:b1,back:b6,guide:b8,leftshoulder:b4,leftstick:b9,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,righttrigger:a3,start:b7,x:b2,y:b3,",
-    "050000005e040000e00200000ffe3f00,Xbox One Wireless Controller,a:b0,b:b1,back:b9,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b3,leftstick:b15,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b18,rightstick:b16,righttrigger:a5,rightx:a3,righty:a4,start:b10,x:b17,y:b2,",
-    "050000005e040000fd020000ffff3f00,Xbox One Wireless Controller,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,leftshoulder:b9,leftstick:b7,lefttrigger:a5,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a4,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
-    "050000005e04000091020000ff073f00,Xbox Wireless Controller,a:b0,b:b1,back:b4,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a3,righty:a4,start:b6,x:b2,y:b3,", /* The DPAD doesn't seem to work on this controller on Android TV? */
-#endif
 #if defined(SDL_JOYSTICK_MFI)
     "05000000ac050000010000004f066d01,*,a:b0,b:b1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,guide:b6,leftshoulder:b4,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,righttrigger:a5,rightx:a3,righty:a4,x:b2,y:b3,",
     "05000000ac05000001000000cf076d01,*,a:b0,b:b1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,guide:b8,leftshoulder:b4,leftstick:b6,lefttrigger:a2,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b7,righttrigger:a5,rightx:a3,righty:a4,x:b2,y:b3,",
diff -uNr SDL2-2.0.10/src/joystick/SDL_sysjoystick.h SDL2-2.0.10.mod/src/joystick/SDL_sysjoystick.h
--- SDL2-2.0.10/src/joystick/SDL_sysjoystick.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/joystick/SDL_sysjoystick.h	2019-08-20 20:44:09.328452555 +0300
@@ -74,7 +74,7 @@
     struct _SDL_Joystick *next; /* pointer to next joystick we have allocated */
 };
 
-#if defined(__IPHONEOS__) || defined(__ANDROID__)
+#if defined(__IPHONEOS__)
 #define HAVE_STEAMCONTROLLERS
 #define USE_STEAMCONTROLLER_HIDAPI
 #elif defined(__LINUX__)
diff -uNr SDL2-2.0.10/src/render/opengles2/SDL_gles2funcs.h SDL2-2.0.10.mod/src/render/opengles2/SDL_gles2funcs.h
--- SDL2-2.0.10/src/render/opengles2/SDL_gles2funcs.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/render/opengles2/SDL_gles2funcs.h	2019-08-20 20:55:14.625069817 +0300
@@ -54,11 +54,7 @@
 SDL_PROC(void, glReadPixels, (GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*))
 SDL_PROC(void, glScissor, (GLint, GLint, GLsizei, GLsizei))
 SDL_PROC(void, glShaderBinary, (GLsizei, const GLuint *, GLenum, const void *, GLsizei))
-#if __NACL__ || __ANDROID__
-SDL_PROC(void, glShaderSource, (GLuint, GLsizei, const GLchar **, const GLint *))
-#else
 SDL_PROC(void, glShaderSource, (GLuint, GLsizei, const GLchar* const*, const GLint *))
-#endif
 SDL_PROC(void, glTexImage2D, (GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const void *))
 SDL_PROC(void, glTexParameteri, (GLenum, GLenum, GLint))
 SDL_PROC(void, glTexSubImage2D, (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
diff -uNr SDL2-2.0.10/src/render/SDL_render.c SDL2-2.0.10.mod/src/render/SDL_render.c
--- SDL2-2.0.10/src/render/SDL_render.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/render/SDL_render.c	2019-08-20 20:54:30.948195093 +0300
@@ -29,10 +29,6 @@
 #include "SDL_sysrender.h"
 #include "software/SDL_render_sw_c.h"
 
-#if defined(__ANDROID__)
-#  include "../core/android/SDL_android.h"
-#endif
-
 #define SDL_WINDOWRENDERDATA    "_SDL_WindowRenderData"
 
 #define CHECK_RENDERER_MAGIC(renderer, retval) \
@@ -446,7 +442,7 @@
 {
     const Uint32 color = ((a << 24) | (r << 16) | (g << 8) | b);
     int retval = 0;
-    
+
     if (!renderer->color_queued || (color != renderer->last_queued_color)) {
         SDL_RenderCommand *cmd = AllocateRenderCommand(renderer);
         retval = -1;
@@ -715,7 +711,7 @@
                 }
             } else if (event->window.event == SDL_WINDOWEVENT_MINIMIZED) {
                 renderer->hidden = SDL_TRUE;
-            } else if (event->window.event == SDL_WINDOWEVENT_RESTORED || 
+            } else if (event->window.event == SDL_WINDOWEVENT_RESTORED ||
                        event->window.event == SDL_WINDOWEVENT_MAXIMIZED) {
                 if (!(SDL_GetWindowFlags(window) & SDL_WINDOW_HIDDEN)) {
                     renderer->hidden = SDL_FALSE;
@@ -840,10 +836,6 @@
     SDL_bool batching = SDL_TRUE;
     const char *hint;
 
-#if defined(__ANDROID__)
-    Android_ActivityMutex_Lock_Running();
-#endif
-
     if (!window) {
         SDL_SetError("Invalid window");
         goto error;
@@ -958,16 +950,10 @@
     SDL_LogInfo(SDL_LOG_CATEGORY_RENDER,
                 "Created renderer: %s", renderer->info.name);
 
-#if defined(__ANDROID__)
-    Android_ActivityMutex_Unlock();
-#endif
     return renderer;
 
 error:
 
-#if defined(__ANDROID__)
-    Android_ActivityMutex_Unlock();
-#endif
     return NULL;
 
 #else
@@ -1287,7 +1273,7 @@
 
     if (format == surface->format->format) {
         if (surface->format->Amask && SDL_HasColorKey(surface)) {
-            /* Surface and Renderer formats are identicals. 
+            /* Surface and Renderer formats are identicals.
              * Intermediate conversion is needed to convert color key to alpha (SDL_ConvertColorkeyToAlpha()). */
             direct_update = SDL_FALSE;
         } else {
@@ -1975,9 +1961,9 @@
         SDL_RenderSetViewport(renderer, NULL);
     } else if (want_aspect > real_aspect) {
         if (scale_policy == 1) {
-            /* We want a wider aspect ratio than is available - 
-             zoom so logical height matches the real height 
-             and the width will grow off the screen 
+            /* We want a wider aspect ratio than is available -
+             zoom so logical height matches the real height
+             and the width will grow off the screen
              */
             scale = (float)h / renderer->logical_h;
             viewport.y = 0;
diff -uNr SDL2-2.0.10/src/SDL.c SDL2-2.0.10.mod/src/SDL.c
--- SDL2-2.0.10/src/SDL.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/SDL.c	2019-08-20 20:44:33.121909496 +0300
@@ -424,8 +424,6 @@
 {
 #if __AIX__
     return "AIX";
-#elif __ANDROID__
-    return "Android";
 #elif __BSDI__
     return "BSDI";
 #elif __DREAMCAST__
@@ -482,10 +480,7 @@
 SDL_bool
 SDL_IsTablet()
 {
-#if __ANDROID__
-    extern SDL_bool SDL_IsAndroidTablet(void);
-    return SDL_IsAndroidTablet();
-#elif __IPHONEOS__
+#if __IPHONEOS__
     extern SDL_bool SDL_IsIPad(void);
     return SDL_IsIPad();
 #else
diff -uNr SDL2-2.0.10/src/SDL_log.c SDL2-2.0.10.mod/src/SDL_log.c
--- SDL2-2.0.10/src/SDL_log.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/SDL_log.c	2019-08-20 20:51:53.260770832 +0300
@@ -33,9 +33,6 @@
 #include <stdio.h>
 #endif
 
-#if defined(__ANDROID__)
-#include <android/log.h>
-#endif
 
 #define DEFAULT_PRIORITY                SDL_LOG_PRIORITY_CRITICAL
 #define DEFAULT_ASSERT_PRIORITY         SDL_LOG_PRIORITY_WARN
@@ -70,27 +67,6 @@
     "CRITICAL"
 };
 
-#ifdef __ANDROID__
-static const char *SDL_category_prefixes[SDL_LOG_CATEGORY_RESERVED1] = {
-    "APP",
-    "ERROR",
-    "SYSTEM",
-    "AUDIO",
-    "VIDEO",
-    "RENDER",
-    "INPUT"
-};
-
-static int SDL_android_priority[SDL_NUM_LOG_PRIORITIES] = {
-    ANDROID_LOG_UNKNOWN,
-    ANDROID_LOG_VERBOSE,
-    ANDROID_LOG_DEBUG,
-    ANDROID_LOG_INFO,
-    ANDROID_LOG_WARN,
-    ANDROID_LOG_ERROR,
-    ANDROID_LOG_FATAL
-};
-#endif /* __ANDROID__ */
 
 
 void
@@ -247,20 +223,6 @@
     va_end(ap);
 }
 
-#ifdef __ANDROID__
-static const char *
-GetCategoryPrefix(int category)
-{
-    if (category < SDL_LOG_CATEGORY_RESERVED1) {
-        return SDL_category_prefixes[category];
-    }
-    if (category < SDL_LOG_CATEGORY_CUSTOM) {
-        return "RESERVED";
-    }
-    return "CUSTOM";
-}
-#endif /* __ANDROID__ */
-
 void
 SDL_LogMessageV(int category, SDL_LogPriority priority, const char *fmt, va_list ap)
 {
@@ -327,7 +289,7 @@
 #if !defined(HAVE_STDIO_H) && !defined(__WINRT__)
         BOOL attachResult;
         DWORD attachError;
-        unsigned long charsWritten; 
+        unsigned long charsWritten;
         DWORD consoleMode;
 
         /* Maybe attach console and get stderr handle */
@@ -342,7 +304,7 @@
                     } else if (attachError == ERROR_GEN_FAILURE) {
                          OutputDebugString(TEXT("Could not attach to console of parent process\r\n"));
                          consoleAttached = -1;
-                    } else if (attachError == ERROR_ACCESS_DENIED) {  
+                    } else if (attachError == ERROR_ACCESS_DENIED) {
                          /* Already attached */
                         consoleAttached = 1;
                     } else {
@@ -369,10 +331,10 @@
         output = SDL_small_alloc(char, length, &isstack);
         SDL_snprintf(output, length, "%s: %s\r\n", SDL_priority_prefixes[priority], message);
         tstr = WIN_UTF8ToString(output);
-        
+
         /* Output to debugger */
         OutputDebugString(tstr);
-       
+
 #if !defined(HAVE_STDIO_H) && !defined(__WINRT__)
         /* Screen output to stderr, if console was attached. */
         if (consoleAttached == 1) {
@@ -393,13 +355,6 @@
         SDL_free(tstr);
         SDL_small_free(output, isstack);
     }
-#elif defined(__ANDROID__)
-    {
-        char tag[32];
-
-        SDL_snprintf(tag, SDL_arraysize(tag), "SDL/%s", GetCategoryPrefix(category));
-        __android_log_write(SDL_android_priority[priority], tag, message);
-    }
 #elif defined(__APPLE__) && (defined(SDL_VIDEO_DRIVER_COCOA) || defined(SDL_VIDEO_DRIVER_UIKIT))
     /* Technically we don't need Cocoa/UIKit, but that's where this function is defined for now.
     */
diff -uNr SDL2-2.0.10/src/stdlib/SDL_getenv.c SDL2-2.0.10.mod/src/stdlib/SDL_getenv.c
--- SDL2-2.0.10/src/stdlib/SDL_getenv.c	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/stdlib/SDL_getenv.c	2019-08-20 20:44:58.288706231 +0300
@@ -29,9 +29,6 @@
 #include "../core/windows/SDL_windows.h"
 #endif
 
-#if defined(__ANDROID__)
-#include "../core/android/SDL_android.h"
-#endif
 
 #include "SDL_stdinc.h"
 
@@ -175,10 +172,6 @@
 char *
 SDL_getenv(const char *name)
 {
-#if defined(__ANDROID__)
-    /* Make sure variables from the application manifest are available */
-    Android_JNI_GetManifestEnvironmentVariables();
-#endif
 
     /* Input validation */
     if (!name || !*name) {
diff -uNr SDL2-2.0.10/src/thread/pthread/SDL_systhread.c SDL2-2.0.10.mod/src/thread/pthread/SDL_systhread.c
--- SDL2-2.0.10/src/thread/pthread/SDL_systhread.c	2019-07-25 07:32:37.000000000 +0300
+++ SDL2-2.0.10.mod/src/thread/pthread/SDL_systhread.c	2019-08-20 20:47:15.999406309 +0300
@@ -52,9 +52,6 @@
 #include "SDL_thread.h"
 #include "../SDL_thread_c.h"
 #include "../SDL_systhread.h"
-#ifdef __ANDROID__
-#include "../../core/android/SDL_android.h"
-#endif
 
 #ifdef __HAIKU__
 #include <kernel/OS.h>
@@ -73,9 +70,6 @@
 static void *
 RunThread(void *data)
 {
-#ifdef __ANDROID__
-    Android_JNI_SetupThread();
-#endif
     SDL_RunThread(data);
     return NULL;
 }
diff -uNr SDL2-2.0.10/src/video/khronos/EGL/eglplatform.h SDL2-2.0.10.mod/src/video/khronos/EGL/eglplatform.h
--- SDL2-2.0.10/src/video/khronos/EGL/eglplatform.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/video/khronos/EGL/eglplatform.h	2019-08-20 20:57:38.325750203 +0300
@@ -83,15 +83,6 @@
 typedef void *EGLNativeWindowType;
 typedef void *EGLNativePixmapType;
 
-#elif defined(__ANDROID__) || defined(ANDROID)
-
-struct ANativeWindow;
-struct egl_native_pixmap_t;
-
-typedef struct ANativeWindow*           EGLNativeWindowType;
-typedef struct egl_native_pixmap_t*     EGLNativePixmapType;
-typedef void*                           EGLNativeDisplayType;
-
 #elif defined(__unix__)
 
 /* X11 (tentative)  */
diff -uNr SDL2-2.0.10/src/video/khronos/KHR/khrplatform.h SDL2-2.0.10.mod/src/video/khronos/KHR/khrplatform.h
--- SDL2-2.0.10/src/video/khronos/KHR/khrplatform.h	2019-07-25 07:32:37.000000000 +0300
+++ SDL2-2.0.10.mod/src/video/khronos/KHR/khrplatform.h	2019-08-20 20:46:46.049255583 +0300
@@ -101,8 +101,6 @@
 #   define KHRONOS_APICALL __declspec(dllimport)
 #elif defined (__SYMBIAN32__)
 #   define KHRONOS_APICALL IMPORT_C
-#elif defined(__ANDROID__)
-#   define KHRONOS_APICALL __attribute__((visibility("default")))
 #else
 #   define KHRONOS_APICALL
 #endif
diff -uNr SDL2-2.0.10/src/video/khronos/vulkan/vk_platform.h SDL2-2.0.10.mod/src/video/khronos/vulkan/vk_platform.h
--- SDL2-2.0.10/src/video/khronos/vulkan/vk_platform.h	2019-07-25 07:32:36.000000000 +0300
+++ SDL2-2.0.10.mod/src/video/khronos/vulkan/vk_platform.h	2019-08-20 20:46:28.129165027 +0300
@@ -51,16 +51,6 @@
     #define VKAPI_ATTR
     #define VKAPI_CALL __stdcall
     #define VKAPI_PTR  VKAPI_CALL
-#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
-    #error "Vulkan isn't supported for the 'armeabi' NDK ABI"
-#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && defined(__ARM_32BIT_STATE)
-    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
-    // calling convention, i.e. float parameters are passed in registers. This
-    // is true even if the rest of the application passes floats on the stack,
-    // as it does by default when compiling for the armeabi-v7a NDK ABI.
-    #define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
-    #define VKAPI_CALL
-    #define VKAPI_PTR  VKAPI_ATTR
 #else
     // On other platforms, use the default calling convention
     #define VKAPI_ATTR
diff -uNr SDL2-2.0.10/src/video/SDL_video.c SDL2-2.0.10.mod/src/video/SDL_video.c
--- SDL2-2.0.10/src/video/SDL_video.c	2019-07-25 07:32:37.000000000 +0300
+++ SDL2-2.0.10.mod/src/video/SDL_video.c	2019-08-20 20:58:02.439197185 +0300
@@ -277,7 +277,7 @@
                 }
             }
         }
-        
+
         if (!renderer) {
             for (i = 0; i < SDL_GetNumRenderDrivers(); ++i) {
                 SDL_RendererInfo info;
@@ -1199,7 +1199,7 @@
     if (SDL_strcmp(_this->name, "cocoa") == 0) {  /* don't do this for X11, etc */
         if (window->is_destroying && (window->last_fullscreen_flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN_DESKTOP)
             return 0;
-    
+
         /* If we're switching between a fullscreen Space and "normal" fullscreen, we need to get back to normal first. */
         if (fullscreen && ((window->last_fullscreen_flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN_DESKTOP) && ((window->flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN)) {
             if (!Cocoa_SetWindowFullscreenSpace(window, SDL_FALSE)) {
@@ -1432,12 +1432,6 @@
         return NULL;
     }
 
-    /* Some platforms have OpenGL enabled by default */
-#if (SDL_VIDEO_OPENGL && __MACOSX__) || __IPHONEOS__ || __ANDROID__ || __NACL__
-    if (!_this->is_dummy && !(flags & SDL_WINDOW_VULKAN)) {
-        flags |= SDL_WINDOW_OPENGL;
-    }
-#endif
     if (flags & SDL_WINDOW_OPENGL) {
         if (!_this->GL_CreateContext) {
             SDL_SetError("OpenGL support is either not configured in SDL "
@@ -1912,7 +1906,7 @@
     /* Fullscreen windows are always at their display's origin */
     if (window->flags & SDL_WINDOW_FULLSCREEN) {
         int displayIndex;
-        
+
         if (x) {
             *x = 0;
         }
@@ -2275,7 +2269,7 @@
     if (SDL_UpdateFullscreenMode(window, FULLSCREEN_VISIBLE(window)) == 0) {
         return 0;
     }
-    
+
     window->flags &= ~FULLSCREEN_MASK;
     window->flags |= oldflags;
     return -1;
@@ -2420,11 +2414,11 @@
     if (!_this->SetWindowModalFor) {
         return SDL_Unsupported();
     }
-    
+
     return _this->SetWindowModalFor(_this, modal_window, parent_window);
 }
 
-int 
+int
 SDL_SetWindowInputFocus(SDL_Window * window)
 {
     CHECK_WINDOW_MAGIC(window, -1);
@@ -2432,7 +2426,7 @@
     if (!_this->SetWindowInputFocus) {
         return SDL_Unsupported();
     }
-    
+
     return _this->SetWindowInputFocus(_this, window);
 }
 
@@ -2664,15 +2658,6 @@
     }
 #endif
 
-#ifdef __ANDROID__
-    {
-        extern SDL_bool Android_JNI_ShouldMinimizeOnFocusLoss(void);
-        if (! Android_JNI_ShouldMinimizeOnFocusLoss()) {
-            return SDL_FALSE;
-        }
-    }
-#endif
-
     return SDL_GetHintBoolean(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, SDL_TRUE);
 }
 
@@ -3036,7 +3021,7 @@
 
 /* Deduce supported ES profile versions from the supported
    ARB_ES*_compatibility extensions. There is no direct query.
-   
+
    This is normally only called when the OpenGL driver supports
    {GLX,WGL}_EXT_create_context_es2_profile.
  */
